<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahé <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="logoslide nobackground">
    <article class="flexbox vcenter">
      <span><img src="images/developers_logo.png"></span>
    </article>
  </slide>

  <slide class="title-slide segue nobackground">
    <aside class="gdbar"><img src="images/developers_icon_128.png"></aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>

  <slide>
    <hgroup>
      <h2>今天的话题</h2>
    </hgroup>
    <article>
      <ul>
        <li>不可磨灭的辉煌历史以及未来十年Java发展路线</li>
        <li>Java1.5以后语法层面一些有用的特性分享</li>
        <li>站在巨人肩上改善代码的设计，提升应用的质量
          <ul>
            <li>Java一些常用的设计模式</li>
            <li>Java的若干条程序设计军规</li>
          </ul>
        </li>
        <li>Groovy、JRudy、Jython、Clojure、Scala、Ceylon、Lua</li>
      </ul>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>Java简介</h2>
    </hgroup>
    <article class="smaller">
        <p>Java是由Sun
        Microsystems公司于1995年5月推出的Java面向对象程序设计语言和JVM平台的总称。由James
        Gosling和同事们共同研发，并在1995年正式推出。</p>
        <ul>
            <li>每年达10亿以上的下载</li>
            <li>900万以上的开发者</li>
            <li>将近97%的企业电脑运行着Java</li>
            <li>40亿台各种设备装有java基本环境</li>        
        </ul>
        <p>Sun 公司对 Java 编程语言的解释是：Java
        编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言。</p>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>Java发展历史</h2>
    </hgroup>
    <article class="smaller">
        <ul class="build fade">
            <li>1995，Java语言诞生</li>
            <li>1996，JDK1.0诞生，多数的操作系统供应商在其产品中嵌入JAVA技术；同时在约8.3万个网页中得以使用</li>
            <li>1997，JDK1.1发布，JavaOne召开，1万人参加创全球同类会议记录；社区蓬勃发展，最大社区人数超过十万</li>
            <li>1998，JDK1.1被下载超过2,000,000次，JAVA2企业平台J2EE发布</li>
            <li>1999，SUN公司发布Java的三个版本：标准版、企业版和微型版</li>
            <li>2000，JDK1.3、JDK1.4发布</li>
            <li>2001，J2SE1.3发布；NOKIA宣布，到2003年将出售1亿部支持Java的手机</li>
            <li>2002，J2SE1.4发布，自此Java的计算能力有了大幅提升</li>
            <li>2004，J2SE1.5发布，成为Java语言发展史上的又一里程碑，SUN对所有版本进行更名</li>
            <li>2006，SUN公司发布JRE6.0，该版本大幅度提高性能</li>
            <li>2007，基于Linux和Harmony的智能手机项目成立，代号Android</li>
            <li>2008，世界上第一台商用Android手机HTC G1诞生</li>            
            <li>2009，甲骨文74亿美元收购Sun。取得java的版权</li>
            <li>2010，由于甲骨文对于Java社区的不友善，因此Apache退出JCP，同时Harmony项目宣布即将终结</li>
            <li>2011，甲骨文发布java7.0的正式版</li>
        </ul>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>Java十年发展路线</h2>
    </hgroup>
    <article class="smaller">
        <ul class="build fade">
            <li>JVM：近年将开始支持越来越多的流行编程语言，包括Groovy、Jython、Ceylon等。</li>
<li>Java 8：提高释放对象能力，易用性以及在云计算方面的优化，提供统一的类型系统和优化数据结构。在云计算方面，JVM为安全的运行多个程序提供多租户功能，及每个线程/线程组之间的资源处理和管理。</li>
<li>Java 9：将新增一些语言上的特性，包括大数据的支持、64位的大数组备份。异种计算模型新增了Java语言对GPU的支持、FPGA、离线引擎、远程PL/SQL。</li>
<li>Java 10及以上：支持扩展函数类型，具有真正的泛型函数类型，包括多维数组数据结构优化。</li>
        </ul>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>Java十年发展路线</h2>
    </hgroup>
    <article class="smaller">
        <table>
        <tr>
          <th></th><th>版本号</th><th>发布时间</th>
        </tr>
        <tr>
          <td>1</td><td>Java 8</td><td>2013年</td>
        </tr>
        <tr>
          <td>2</td><td>Java 9</td><td>2015年</td>
        </tr>
        <tr>
          <td>3</td><td>Java 10</td><td>2017年</td>
        </tr>
        <tr>
          <td>4</td><td>Java 11</td><td>2019年</td>
        </tr>
        <tr>
          <td>5</td><td>Java 12</td><td>2021年</td>
        </tr>
      </table>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>Java1.5以后的语法级新特性一览<h2>
    </hgroup>
    <article>
        <img src="images/hot_java.png" class="reflect" alt="Description" title="Description">
        <footer class="source">对与语言来说，我们期望其核心部分尽可能简洁</footer>
    </article>
    </slide>
  <slide>
    <hgroup>
      <h2>范型与For-Each循环<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
//范型
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
//list.add(1);编译期错误
list.add("1");
        </pre>
        <pre class="prettyprint" data-lang="java">
//For-Each循环
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add("1");
list.add("2");
list.add("3");
list.add("4");
for(String word:list){
    System.out.println(word);
}            
        </pre>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>自动装箱拆箱与枚举类型<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
//自动装箱拆箱
Integer i = 1;//类型自动转换
int j = i;//类型自动转换
        </pre>
        <pre class="prettyprint" data-lang="java">
//枚举类型
public enum Color{
    Red,
    White,
    Blue
}
        </pre>
    </article>
  </slide>

      <slide>
    <hgroup>
      <h2>可变参数列表与静态导入<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
//可变参数列表
public void write(String... args){
    for(String arg:args){
        System.out.println(arg);
    }
}
        </pre>
        <pre class="prettyprint" data-lang="java">
//静态导入
import static java.lang.System.*;

public void print(String arg){
    out.println(arg);
}
        </pre>
    </article>
  </slide>
      <slide>
    <hgroup>
      <h2>Switch支持字符串<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public static void testSwitch(){  
    String type="apple";  
    switch(type){  
        case "apple":  
            System.out.println("dear");  
            break;  
        case "amd":  
            System.out.println("amd");  
            break;  
        case "lenovo":  
            System.out.println("le");  
            break;  
    }  
}
        </pre>
    </article>
  </slide>

      <slide>
    <hgroup>
      <h2>范型推导与多异常捕获<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
//范型推导
List&lt;String&gt; nameList = new ArrayList&lt;&gt;(16);  
nameList.add("Terry");
        </pre>
        <pre class="prettyprint" data-lang="java">
//多异常捕获 
try { 
    testException("first"); 
} catch (FirstException | SecondException e) { 
    System.out.println(e.getMessage()); 
}
        </pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>try-with-resources<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
//try-with-resources能够确保需要关闭的资源在声明结束后被关闭 
//但是需要被关闭的资源必须实现AutoCloseable接口  
private static void customBufferStreamCopy(File source, File target) {
    try (InputStream fis = new FileInputStream(source);
        OutputStream fos = new FileOutputStream(target)){
        byte[] buf = new byte[8192];
        int i;
        while ((i = fis.read(buf)) != -1) {
            fos.write(buf, 0, i);
        }
    }
    catch (Exception e) {
        e.printStackTrace();
    }
}
        </pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>lambda表达式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
//闭包（匿名内部类）
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        ui.dazzle(e.getModifiers());
    }
});
//lambda表达式
button.addActionListener(e -> { ui.dazzle(e.getModifiers()); });

//lambda表达式
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Dave");
names.filter(e -> e.length() >= 4).forEach(e -> { System.out.println(e); });
        </pre>
        <pre  class="prettyprint" data-lang="python">
names = ["Alice", "Bob", "Charlie", "Dave"]
print(filter(lambda name:len(name) >= 4,names))
        </pre>
    </article>
  </slide>

 <slide>
    <hgroup>
      <h2>站在巨人肩上提升应用质量</h2>
    </hgroup>
    <article class="smaller">
        <ul>
            <li>Java常用的设计模式与简单用法</li>
            <li>Java反模式与若干条程序设计军规</li>
        </ul>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>单例设计模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public class EagerSingleton 
{ 
	private static final EagerSingleton m_instance = new EagerSingleton(); 
	/** 
	* 私有的默认构造子 
	*/ 
	private EagerSingleton() { } 
	/** 
	* 静态工厂方法 
	*/ 
	public static EagerSingleton getInstance() {
		return m_instance; 
	}
} 
        </pre>
        <p>实例化代价很高或者全局共享一个实例时使用，应注意多线程！</p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>适配器设计模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
//我们需要接口
interface Target { 
    void Request(); 
} 
//已有实现
class Adaptee {
    void SpecificRequst() { 
        System.out.println("Adaptee's SpecificRequst"); 
    } 
}
//适配后的类
class Adapter extends Adaptee implements Target  { 
    @Override 
    public void Request() { 
         System.out.println("Adapter's Request"); 
         super.SpecificRequst(); 
    } 
}
        </pre>
        <p>现有的实现能够满足我们的需要，但是接口不一致时使用</p>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>代理设计模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public interface Subject {  
    public void doSomething();  
}
public class RealSubject implements Subject {  
    @Override  
    public void doSomething() {  
        System.out.println("RealSubject.doSomething");  
    }  
}
import java.lang.reflect.InvocationHandler;  
import java.lang.reflect.Method; 
public class DynamicProxy implements InvocationHandler {  
    private Object object;  
    public DynamicProxy(Object object) {  
        this.object = object;  
    }     
    @Override  
    public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {  
        Object result = method.invoke(object, args);
        return result;  
    }  
}
        </pre>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>代理设计模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
import java.lang.reflect.InvocationHandler;  
import java.lang.reflect.Proxy;  
public class Client {  
    public static void main(String[] args) throws Exception {  
        RealSubject realSubject = new RealSubject();             
        InvocationHandler handler = new DynamicProxy(realSubject);  
        Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(),  
                    Subject.class,handler);  
        subject.doSomething();  
    }  
}  
        </pre>
        <p>为其他对象提供一种代理以控制对这个对象的访问。</p>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>观察者设计模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public interface RandomNumberListener {//接口
	public void numberChanged(double d);
}
public class Consol implements RandomNumberListener{
	@Override
	public void numberChanged(double d) {
		System.out.println(d);
	}
}
public class SwingWindow extends JFrame implements RandomNumberListener{//观察者
	private JLabel label = new JLabel();
	public SwingWindow(){
	    this.getContentPane().add( label);
	    this.setSize(300,200);
	    this.setVisible(true);
	}
	@Override
	public void numberChanged(double d) {
		label.setText(String.valueOf(d));
	}
}
        </pre>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>观察者设计模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public class RandomNumber {//业务
    private double r;
    private List&lt;RandomNumberListener&gt;  listeners = new ArrayList&lt;RandomNumberListener&gt;();
    public void addRandomNumberListener(RandomNumberListener lis){
	listeners.add(lis);
    }
    public void random()(){
	r = Math.random()();
	for (RandomNumberListener lis : listeners) {
	    lis.numberChanged(r);
	}
    }
}
        </pre>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>观察者设计模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public class Test {
    public static void main(String[] args) throws InterruptedException{
	RandomNumber rn = new RandomNumber();
	SwingWindow sw = new SwingWindow();
	Consol c = new Consol();
	rn.addRandomNumberListener(sw);
	rn.addRandomNumberListener(c);
	while(true){
	    rn.random();
	    Thread.sleep(new Random().nextInt(3000)+1000L);
	}
    }
}
        </pre>
        <p>常用于监听对象内部的状态变化</p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>装饰器模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public interface Sourcable {  
    public String operation(); 
}
public class Source implements Sourcable {  
    public String operation() {  
        return "原始类的方法";  
    } 
}
public class LowerDecorator implements Sourcable {  
  
    private Sourcable sourcable;  
    public Decorator2(Sourcable sourcable){  
        super();  
        this.sourcable=sourcable;  
    }  
    public String operation() {  
        return sourcable.operation().lower();
    }  
}
        </pre>
        <p>动态地给一个对象添加一些额外的职责或者行为。</p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>模板模式<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
public abstract class Benchmark{
　　public abstract void benchmark();
　　public final long repeat (int count) {
　　　　if (count &lt;= 0){
　　　　　　return 0;
　　　　}else {
　　　　　　long startTime = System.currentTimeMillis();

　　　　    for (int i = 0; i &lt; count; i++) 
　　　　　　    benchmark();
　　　　    long stopTime = System.currentTimeMillis();
　　　　    return stopTime - startTime;
　　    }
    }
}
class ForBenchmark extends Benchmark{
    public void benchmark(){
        for(int i = 0;i&lt;10000000;i++){
        }
    }
}
        </pre>
        <p>定义一个操作中算法的骨架,将一些步骤的执行延迟到其子类中。</p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>以上抛砖引玉，仅仅是一个开始<h2>
    </hgroup>
    <article class="smaller">
        <img src="images/thinking.png" class="reflect" alt="Description" title="Description">
        <footer class="source">路漫漫其修远兮 吾将上下而求索</footer>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>Java的若干条军规<h2>
    </hgroup>
    <article class="smaller">
        <img src="images/jungui.jpg" class="reflect" alt="Description" title="Description">
        <footer class="source">离娄之明,公输子之巧,不以规矩,不成方圆</footer>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>用静态方法代替构造器<h2>
    </hgroup>
    <article class="smaller">
        <p>对于类而言，为了让客户端获取它自身的一个实例，最常用的方法就是提供一个公有的构造器。</p>
        <pre class="prettyprint" data-lang="java">
public Boolean(boolean b){}
public Boolean(String b){}
public Boolean(int b){}
        </pre>        
        <p>如果对象不可变或者参数类型过多，可以使用静态工厂方法代替构造器。静态工厂方法和公有构造器都各有用处，我们需要理解它们各自的长处。静态工厂通常更加合适参数较多或者对象不可变的情况，因此大多数情况我们应该优先考虑静态工厂。</p>
        <pre class="prettyprint" data-lang="java">
public static Boolean valueOf(boolean b){
    return b?Boolean.TRUE:Boolean.FALSE;
}
public static Boolean valueOf(String b){
    return b!=null?Boolean.TRUE:Boolean.FALSE;
}
public static Boolean valueOf(int b){
    return b>0?Boolean.TRUE:Boolean.FALSE;
}
        </pre>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>避免创建不必要的对象<h2>
    </hgroup>
    <article class="smaller">
        <p>一般来说最好能够重用对象而不是在每次需要的时候就创建一个相同功能的新对象，如果对象是不可变的，那么他就可以重用。</p>
        <pre class="prettyprint" data-lang="java">
String s = new String("hello");//bad
String s = "hello";//good
        </pre>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>避免使用finalizer方法<h2>
    </hgroup>
    <article class="smaller">
        <p>终结方法finalizer通常是不可预测的，也是很危险的.一般情况下是不必要的。使用终结方法会导致行为不稳定，降低性能，以及可移植性问题。</p>
        <pre class="prettyprint" data-lang="java">
@Override
protected void finalize() throws Throwable{
    try{
       //终结子类的状态
    }finally{
        super.finalize();
    }
}
        </pre>
        <p>根据经验，应避免使用终结方法。Java语言规范不仅不能保证终结方法会被及时的执行，而且根本就不保证他们会执行。该方法具有固有的不安全性。它可能对正在使用的对象调用终结方法，而其他线程同时正在操作这些对象，从而导致不正确的行为或死锁。</p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>重写equals必须重写hashcode<h2>
    </hgroup>
    <article class="smaller">
        <p>在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 在覆盖equals方法的时候，你必须要遵守它的通用约定。</p>
<li>自反性。对于任何非null的引用值x，x.equals(x)必须返回true。</li>
<li>对称性。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true</li>
<li>传递性。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。</li>
<li>一致性。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用该x.equals(y)就会一直地返回true，或者一致地返回false。</li>
<li>对于任何非null的引用值x，x.equals(null)必须返回false。 </li>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>使类和成员的可访问性最小化 <h2>
    </hgroup>
    <article class="smaller">
        <p>要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其他细节。</p>
        <pre class="prettyprint" data-lang="java">
public static final String[] PRIVATE_VALUES = {"a","c"};  
        </pre>
        <p>设计良好的模块会隐藏所有的实现细节，把他的API和他的实现清晰的分割开来。然后，模块之间通过他们之间的API进行通信，一个模块不需要知道其他模块的内部情况，这样才能最大程度的解耦合。</p>
			<pre class="prettyprint" data-lang="java">
private static final String[] PRIVATE_VALUES = {"a","c"};  
public static final Thing[] values() {  
    return PRIVATE_VALUES.clone();  
}
        </pre>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>复合优于继承<h2>
    </hgroup>
    <article class="smaller">
        <p>面向对象编程的新手通常会犯这样的错误，他们对任何东西都想使用继承，例如让类Car继承Engine类。</p>
        <pre class="prettyprint" data-lang="java">
class Engine{public void run(){}}
class Car extends Engine{

}
        </pre>
        <p>继承确实是个有趣的新工具，但它并非适用于所有情况。你可以用上述的继承结构创建可正常工作的程序，因为Car代码中使发动机运行的那部分可访问。但是其他人在阅读这段代码时会觉得不合理。汽车是台发动机？当然不是。所以，只应在恰当的时候使用继承。继承破坏了面向对象思想中的封装特性，这是因为子类继承父类会对父类的封装进行重写而破坏原有的父类的封装，只有明确是继承关系的时候才用继承。</p>
        <pre class="prettyprint" data-lang="java">
class Engine{public void run(){}}
class Car{
	private Engine engine = new Engine();
	public void run(){
		engine.run()
	}
}
        </pre>    
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>接口只用于定义类型<h2>
    </hgroup>
    <article class="smaller">
        <p>当类实现接口时，接口就充当可以引用这个类的实例的类型。因此类实现了接口，就表明客户端可以对这个类的实例实施某些动作。为了其他目的而使用接口是不恰当的。</p>
        <pre class="prettyprint" data-lang="java">
public interface RP {//bad
  public static final boolean GOOD=0;  
  public static final boolean BAD =1;  
} 
        </pre>
        <p>常量接口模式是对接口的不良使用。如果这些常量最好被看作枚举类型的成员，使用枚举类型。否则，应该使用不可实例化的工具类来导出这些常量。</p>
        <pre class="prettyprint" data-lang="java">
enum RP{//good
    GOOD,BAD
}
        </pre>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>最小化局部变量的作用域<h2>
    </hgroup>
    <article class="smaller">
        <p>过早的声明一个局部变量，不仅会使它的作用域过早开始，还可能使它的作用域过迟结束。局部变量的作用域从声明它的地方开始，到所在块的结束处结束。如果在使用变量的语句块外面声明变量，哪么在语句块结束后，这个变量仍是可见的。如果变量在其使用域之前或之后被偶然使用，结果可能是灾难性的。</p>
        <pre class="prettyprint" data-lang="java">
Iterator<Element> i = c.iterator()
while(i.hasNext()){}
Iterator<Element> i2 = c2.iterator()
while(i.hasNext()){}
        </pre>
		<p>循环语句是展示最小化变量作用域的特别时机。For循环，无论是传统的还是for-each形式，都允许声明循环变量，从而限制了循环变量的作用域只在需要它们的区域内，因此，如果循环结束后不再需要循环变量，哪么for循环优于while循环。</p>        
        <pre class="prettyprint" data-lang="java">
//迭代集合优先使用for each而不是传统的计数迭代
for (int i =0;i&lt;c.size();i++) {//bad
    Element e = c.get(i)
    doSomething(e);
}
for (Element e : c) {//good
    doSomething(e);
}
        </pre>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>如果要精确计算避免使用float和double<h2>
    </hgroup>
    <article class="smaller">
        <p>float和double类型的主要设计目的是为了科学计算和工程计算。它们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。float和double类型对于货币计算尤为不合适，因为要让一个float或者double精确地表示0.1(或者10的任何负数次方值)是不可能的，比如System.out.println(2.0-1.1)将会打印0.899999999999999,而不是你所希望的0.9，这种舍入错误产生的原因是浮点数实际上是用二进制系统实现的，解决方法是使用BigDecimal、int或long(将小数转换为整数再进行计算，例如：将以美元为单位的货币计算改为以美分为单位的货币计算)。</p>
    </article>
  </slide>


    <slide>
    <hgroup>
      <h2>避免使用字符串拼接<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
  public void testPlus() { 
        String s = "";
        long ts = System.currentTimeMillis();
        for (int i = 0; i &lt; 10000; i++) {
            s = s + String.valueOf(i);
        }
        long te = System.currentTimeMillis();
        logger.info("+ cost {} ms", te - ts);
    }
        </pre>
        <pre class="prettyprint" data-lang="java">
    public void testStringBuilder() {
        StringBuilder sb = new StringBuilder();
        long ts = System.currentTimeMillis();
        for (int i = 0; i &lt; 100000; i++) {
            sb.append(String.valueOf(i));
        }
        sb.toString();
        long te = System.currentTimeMillis();
        logger.info("StringBuilder cost {} ms", te - ts);
    }
        </pre>
<p>两者之间的性能相差10倍，尽量避免字符串拼接，如果多线程拼接考虑使用StringBuffer。</p>
    </article>
  </slide>


    <slide>
    <hgroup>
      <h2>Executor 和 Task优先于线程<h2>
    </hgroup>
    <article class="smaller">
        <pre class="prettyprint" data-lang="java">
ExecutorService executor = Executors.newSingleThreadExecutor();
executor.execute(runnable);
executor.shutdown();
        </pre>
<p>他可以比线程更优雅的关闭，甚至可以提供可复用的线程池，甚至可以代替Timer，总之在1.5以后的版本尽量避免使用原生的线程。</p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>RuntimeException vs Exception<h2>
    </hgroup>
    <article class="smaller">
        <span>选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。</span>
        <pre class="prettyprint" data-lang="java">
Connection con = null;			
try{
    con = connect();
}catch(SocketException e){				
    con = reconnect();
    if(con == null){
        logger.error(e);				
    }else{
        logger.debug(e);
    }
}
        </pre>					
		<p>大多数情况下我们遵循：为可恢复的错误使用检查型异常，为编程错误使用非检查型错误</p>    
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>在finally中释放资源<h2>
    </hgroup>
    <article class="smaller">
        <span>这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源，在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由try finally块保证。</span>
        <pre class="prettyprint" data-lang="java">
Lock lock = new WriteableLock();
try{
    lock.lock();
}finally{
    lock.release();
}
        </pre>
        <p>从Java7开始，有了一项更有趣的功能：资源管理自动化或者ARM块能实现这一功能。尽管如此，我们仍然要记住在finally块中释放资源，因为并不是所有的类都提供ARM块功能。 </p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>在堆栈中跟踪包含引起异常的深层原因<h2>
    </hgroup>
    <article class="smaller">
        <span>很多时候，当一个异常是由另一个异常导致的时候，基础类库通常会将一种异常包装成其他异常。</span>
        <pre class="prettyprint" data-lang="java">
try{
    do();
}cache(IOException e){
    throw new FileNotFoundException(e);
}
        </pre>
        <span>始终提供关于异常有意义的完整信息。</span>
        <pre class="prettyprint" data-lang="java">
            //bad
            throw new IllegalArgumentException("Incorrect argument for method")
            //good
            throw new IllegalArgumentException("Illegal value for name:'bing'")
        </pre>
        <p>Java异常类提供了getCause()方法来检索导致异常的深层原因，这些原因可以对异常的根层次的原因提供更多的信息，这样做对调试或排除故障有很大的帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。</p>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>避免过度使用检查型异常<h2>
    </hgroup>
    <article class="smaller">
        <span>检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码正常逻辑。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更简洁的代码。我们还可以将无法处理或者想要统一处理的异常统一包装成运行时异常。 </span>
        <pre class="prettyprint" data-lang="java">
try{
    do();
}cache(Exception e){
    throw new RuntimeException(e);
}
        </pre>
        <p>诸如Spring、XStream之类的多数框架中限制使用检查型异常；在Spring框架中大部分出自于JDBC的检查类型异常，都被包装进非检查型异常DataAccessException中。特定的异常限制到特定的模块，像 SQLException 放到DAO层，将意思明确的运行时异常抛到客户层。</p>
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>记住对性能而言，异常代价高昂<h2>
    </hgroup>
    <article class="smaller">
        <span>假如你有方法从ResultSet（结果集）中进行读取，这时常会抛出SQLException异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。</span>
        <pre class="prettyprint" data-lang="java">
//性能至上的场合千万不要这么做。
if(length &lt; 0){
    throw new ValueException();
}
        </pre>
        <p>因此最大限度的减少不必要的异常捕捉和移动，是解决问题的根本方式。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免使用不必要的异常。</p>
        <pre class="prettyprint" data-lang="java">
if(length &lt; 0){
    return false;
}
        </pre> 
        <p>需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。</p>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>避免catch块为空<h2>
    </hgroup>
    <article class="smaller">
        <span>没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。</span>
        <pre class="prettyprint" data-lang="java">
//bad
try{
    do();
}catch(Exception e){
}
//good
try{
    do();
}catch(Exception e){
    logger.debug(e);
}
        </pre>
        <p>空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，用日志记录错误依然是最好的方法。编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。</p>
    </article>
  </slide>
  <slide>
    <hgroup>
      <h2>其他异常最佳实践<h2>
    </hgroup>
    <article class="smaller">
        <ul>
            <li>尽可能重用标准异常，这样可显著增强代码的可读性。</li>
            <li>在Java doc中明确说明抛出异常的种类，如果编写公用类库这个很重要。</li>
        </ul>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>JVM上的其他语言<h2>
    </hgroup>
    <article class="smaller">
      <span>近年来，Java领域最有影响力的趋势之一是JVM（Java虚拟机）上对于非Java语言的支持。JVM作为一种机制用以提供Java应用在不同的环境，其他平台以及不同硬件上的可移植性，而基于JVM平台的编程语言也是不断的在增加。</span>
		<img src="images/jvm_lang.png">		
		<p>从动态语言如Groovy、JRuby, Jython到静态型Scala语言， JVM也正成为一个多元化的平台，开发人员可以充分利用不同语言来满足各自不同的需求。</p>    
    </article>
  </slide>

    <slide>
    <hgroup>
      <h2>Groovy<h2>
    </hgroup>
    <article class="smaller">
        <p>Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy 可以使用其他 Java 语言编写的库。</p>
        <pre class="prettyprint" data-lang="groovy">
class Greet {
  def name
  Greet(who) { name = who[0].toUpperCase() +
                      who[1..-1] }
  def salute() { println "Hello $name!" }
}
g = new Greet('world')  // create object
g.salute()               // output "Hello World!"
        </pre>
    </article>
  </slide>
    <slide>
    <hgroup>
      <h2>Scala<h2>
    </hgroup>
    <article class="smaller">
        <p>Scala是一种多范式的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。</p>
        <pre class="prettyprint" data-lang="scala">
object  HelloWorld {
   def main(args: Array[String]) {
       println("Hello，Scala的HelloWorld程序！")
   }
}
        </pre>
    </article>
  </slide>
      <slide>
    <hgroup>
      <h2>JRuby<h2>
    </hgroup>
    <article class="smaller">
        <p>JRuby是面向Ruby、基于Java虚拟机(JVM)的一种解释程序，它结合了Ruby语言的简易性和功能强大的JVM的执行机制，包括与Java库全面集成。</p>
        <pre class="prettyprint" data-lang="jruby">
include_class "java.util.HashMap"     
x = HashMap.new     
x.put("foo","bar")
        </pre>
    </article>
  </slide>
      <slide>
    <hgroup>
      <h2>Jython<h2>
    </hgroup>
    <article class="smaller">
    <p>Jython是一种完整的语言，而不是一个Java翻译器或仅仅是一个Python编译器，它是一个Python语言在Java中的完全实现。</p>
        <pre class="prettyprint" data-lang="jython">
from java.util import HashMap
b=HashMap()
b.put("a", "1")
b.put("b","2")
        </pre>
    </article>
  </slide>

      <slide>
    <hgroup>
      <h2>Clojure<h2>
    </hgroup>
    <article class="smaller">
        <p>Lisp
        是一种编程语言，以表达性和功能强大著称，但人们通常认为它不太适合应用于一般情况。Clojure是一种运行在 Java™ 平台上的 Lisp 方言。</p>
        <pre class="prettyprint" data-lang="clojure">
(doto (new java.util.HashMap) (put "a" 1) (put "b" 2))
        </pre>
    </article>
  </slide>

  <slide>
    <hgroup>
      <h2>JVM未来走向平台化<h2>
      <h3>长远来看Java平台比Java语言有更重要</h3>
    </hgroup>
    <article>
        <img src="images/ma.jpg" class="reflect" alt="Description" title="Description">
        <footer class="source"> 老骥伏枥,志在千里; 烈士暮年,壮心不已。</footer>
    </article>
  </slide>


  <slide class="thank-you-slide segue nobackground">
    <aside class="gdbar right"><img src="images/developers_icon_128.png"></aside>
    <article class="flexbox vleft auto-fadein">
      <h2>&lt;Thank You!&gt;</h2>
      <p>Important contact information goes here.</p>
    </article>
    <p class="auto-fadein" data-config-contact>
      <!-- populated from slide_config.json -->
    </p>
  </slide>

  <slide class="logoslide dark nobackground">
    <article class="flexbox vcenter">
      <span>Q&A</span>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
